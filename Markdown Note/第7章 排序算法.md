#数据结构与算法 

> 面对海量数据，选择合适的算法显得尤为重要。
> 在实际进行时，往往搭配**预处理**来提高效率。

本章的**三个要求**：
1. 每种算法思想都要掌握
2. 查找时要清楚比较次数（ASL）和移动次数。（稳定性）
3. 掌握每种查找的最好情况和最坏情况，平均情况。 

# 7.1 排序的基本概念

假定文件是由 n 个记录组成的序列，其相应的关键字序列为 (K₁, K₂, ..., Kₙ)。

**排序**就是将数据元素的任意序列，按关键字排成人们需要的序列（通常是升序或降序）。

### 排序结果的唯一性

- 若待排序序列中所有关键字均不相同，则排序结果是**唯一**的。
- 若存在关键字相同的记录，则排序结果可能**不唯一**，这取决于排序算法的稳定性。

### 排序算法的稳定性

若待排序序列中存在两个或两个以上关键字相等的记录 Rᵢ 和 Rⱼ (i<j)，排序后它们的相对次序保持不变，即 Rᵢ 仍在 Rⱼ 之前，则称该排序算法是**稳定的**；否则称为**不稳定的**。

**注意**：排序算法的稳定性是针对所有输入实例而言的。一个算法不能因为对某个特定实例产生了稳定的结果就被认为是稳定的。稳定性由算法本身决定。

## 存储结构

通常的存储方式有如下三种：
1. 顺序表
2. 链表
3. 二叉树等树形结构

# 7.2 简单排序
> 简单排序算法时间复杂度均为$O(n^2)$，基本有序的时候“快”。
## 7.2.1 简单插入排序
**基本思想**：将待排序序列分为已排序区和未排序区。每次从未排序区取出一个元素，在已排序区中从后向前扫描，找到相应位置并插入。
```cpp
void insertionSort(int arr[], int n) {
    for (int i = 1; i < n; i++) {
        int key = arr[i];
        int j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        arr[j + 1] = key;
    }
}
```

## 7.2.2 简单冒泡排序
**基本思想**：重复地遍历待排序序列，一次比较两个相邻的元素，如果它们的顺序错误就把它们交换过来。
```cpp
void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
            }
        }
    }
}
```
优化后：加入flag记录某一趟是否已经交换过。
![](../图片/IMG_20251126_081050.jpg)
## 7.2.3 简单选择排序
**基本思想**：每次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。(存放下标而不是直接赋值)
```cpp
void selectionSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        int min_idx = i;
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[min_idx])
                min_idx = j;
        }
        swap(arr[i], arr[min_idx]);
    }
}
```

> 简单选择排序的关键字比较次数和待排序的初始序列**无关**，简单排序算法是一种不稳定的排序算法。

# 7.3 高级排序
> 高级排序的时间复杂度基本都是$O(nlog(n))$
## 7.3.1 希尔排序（Shell）
- 希尔排序是对简单插入排序算法的一种改进，又称为**缩小增量排序**
**基本思想**：将数组按增量d分组，对每组进行插入排序，逐步缩小d直到1，然后对全部数进行选择排序。
**稳定性**：不稳定。
```cpp
void shellSort(int arr[], int n) {
    for (int gap = n/2; gap > 0; gap /= 2) {
        for (int i = gap; i < n; i++) {
            int key = arr[i];
            int j = i;
            while (j >= gap && arr[j - gap] > key) {
                arr[j] = arr[j - gap];
                j -= gap;
            }
            arr[j] = key;
        }
    }
}
```
![](../图片/IMG_20251126_084230.jpg)

在最后一趟排序之前，希尔排序的序列就已经基本有序了。

## 7.3.2 快速排序
**基本思想**：选择一个基准元素，将数组分成小于和大于基准的两部分，递归排序子数组。
**稳定性**：不稳定。
```cpp
int partition(int arr[], int low, int high) {
    int pivot = arr[low];
    int i = low - 1;
    for (int j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++;
            swap(arr[i], arr[j]);
        }
    }
    swap(arr[i + 1], arr[high]);
    return i + 1;
}
void quickSort(int arr[], int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, low, pi + 1);
    }
}
```
- 最好情况：每次正好在中间分，类似于完全二叉树

## 7.3.3 归并排序（Merge）
需要掌握2路归并算法，明白算法流程即可。

## 7.3.4 树形排序：锦标赛选择排序
> 待排序关键字不能相同，否则不能判断胜者。

```cpp
int OnePassTree(STable T)
```

**缺点**：需要大量的空间；没有利用先前的结果。
## 7.3.5 树形排序：堆排序（HeapSort）
堆排序解决了上一个排序算法的的两个缺点。